<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jarvis Holographic Core | Biometric Interface</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #0ff;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #status-panel {
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 20, 40, 0.5);
            padding: 15px;
            border-left: 2px solid #0ff;
            max-width: 300px;
            backdrop-filter: blur(4px);
        }

        .hud-text {
            font-size: 12px;
            line-height: 1.5;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
        }

        .hud-value {
            font-weight: bold;
            color: #fff;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: 16px;
            font-family: inherit;
            cursor: pointer;
            pointer-events: all;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        #start-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
        }

        /* Video feed for debug (hidden by default, can toggle if needed) */
        #video-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            opacity: 0.3;
            transform: scaleX(-1); /* Mirror */
            border: 1px solid #0ff;
            display: none; /* Hidden for cinematic feel */
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div id="status-panel">
            <p class="hud-text">SYS.STATUS: <span id="sys-status" class="hud-value">STANDBY</span></p>
            <p class="hud-text">AUDIO.IN: <span id="audio-status" class="hud-value">INACTIVE</span></p>
            <p class="hud-text">VISUAL.IN: <span id="vision-status" class="hud-value">SEARCHING</span></p>
            <p class="hud-text" style="margin-top:10px; opacity:0.7;">GESTURES: PALM (Heal) | FIST (Break) | PINCH (Scan)</p>
        </div>
        <button id="start-btn">Initialize System</button>
    </div>

    <video id="video-feed" playsinline></video>

    <script>
    /**
     * SENIOR ENGINEER IMPLEMENTATION NOTE:
     * * Architecture:
     * 1. App: Main controller, handles Three.js scene, loop, and uniforms.
     * 2. AudioManager: Handles Web Audio API, FFT analysis.
     * 3. VisionManager: Handles MediaPipe Hands, state detection.
     * * Shaders are written in raw GLSL within the JS for single-file portability.
     */

    // --- GLSL SHADERS ---

    const vertexShader = `
        uniform float uTime;
        uniform float uExplode;      // 0.0 = Organized, 1.0 = Exploded
        uniform float uAudioLow;     // Bass for scaling
        uniform float uScanRadius;   // Current radius of the scan wave
        uniform float uScanActive;   // 0.0 or 1.0

        attribute vec3 basePosition; // Original resting position
        attribute float aRandom;     // Random seed per particle

        varying float vAlpha;
        varying vec3 vColor;
        varying float vDist;

        // Simplex Noise (Lightweight implementation for movement)
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0);
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute( 
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                      + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            // 1. Base Motion: Idle floating based on noise
            float noiseVal = snoise(basePosition * 0.5 + uTime * 0.2);
            vec3 noiseOffset = vec3(
                snoise(basePosition * 1.0 + uTime * 0.1),
                snoise(basePosition * 1.0 + uTime * 0.1 + 10.0),
                snoise(basePosition * 1.0 + uTime * 0.1 + 20.0)
            ) * 0.5; // Small organic float

            // 2. Audio Reactivity (Breathing)
            vec3 pos = basePosition + noiseOffset;
            float pulse = 1.0 + (uAudioLow * 0.5); // Expand on bass
            pos *= pulse;

            // 3. Explosion Logic (Radial + Chaos)
            vec3 explodeDir = normalize(basePosition);
            // Mix between orderly sphere and exploded chaos
            vec3 explodedPos = pos + (explodeDir * 15.0 * (aRandom + 0.5)) + (noiseOffset * 5.0);
            
            // Smooth interpolation
            vec3 finalPos = mix(pos, explodedPos, uExplode);

            // 4. Scan Wave Logic
            float distFromCenter = length(finalPos);
            float waveWidth = 2.0;
            float inScan = 0.0;
            
            if (uScanActive > 0.5) {
                // Calculate if particle is inside the wave band
                float distDiff = abs(distFromCenter - uScanRadius);
                // Smoothstep for soft wave edges
                inScan = 1.0 - smoothstep(0.0, waveWidth, distDiff);
                
                // Displace particles slightly when scanned
                finalPos += normalize(finalPos) * inScan * 0.5;
            }

            // 5. Output
            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // Size calculation
            // Base size + Audio kick + Scan boost
            float size = (4.0 * (1.0 + uAudioLow)) + (inScan * 10.0);
            
            // Perspective attenuation (make distant particles smaller)
            gl_PointSize = size * (300.0 / -mvPosition.z);

            // Passing data to fragment
            vAlpha = 0.6 + (inScan * 0.4); // Brighter if scanned
            vDist = distFromCenter;
            
            // Color shift based on position/scan
            vec3 baseColor = vec3(0.0, 0.8, 1.0); // Cyan
            vec3 scanColor = vec3(1.0, 1.0, 1.0); // White hot
            vColor = mix(baseColor, scanColor, inScan);
        }
    `;

    const fragmentShader = `
        uniform float uAudioMid;
        varying float vAlpha;
        varying vec3 vColor;

        void main() {
            // Circular Particle
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if (dist > 0.5) discard;

            // Radial Glow (Soft edge)
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.5); // Sharpen the falloff

            // Audio Mid frequencies affect brightness
            float brightness = 1.0 + uAudioMid * 2.0;

            vec3 finalColor = vColor * brightness;

            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    `;

    // --- SYSTEMS ---

    class AudioManager {
        constructor() {
            this.context = null;
            this.analyser = null;
            this.dataArray = null;
            this.active = false;
            this.lows = 0;
            this.mids = 0;
        }

        async init() {
            try {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = this.context.createMediaStreamSource(stream);
                
                this.analyser = this.context.createAnalyser();
                this.analyser.fftSize = 512;
                source.connect(this.analyser);
                
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.active = true;
                
                document.getElementById('audio-status').textContent = "ACTIVE";
                document.getElementById('audio-status').style.color = "#0f0";
            } catch (e) {
                console.warn("Audio init failed:", e);
                document.getElementById('audio-status').textContent = "DENIED";
                document.getElementById('audio-status').style.color = "#f00";
            }
        }

        update() {
            if (!this.active) return;
            
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Calculate Bass (Lows) - approx first 10% of bins
            let lowSum = 0;
            const lowBins = Math.floor(this.dataArray.length * 0.1);
            for(let i=0; i<lowBins; i++) lowSum += this.dataArray[i];
            this.lows = (lowSum / lowBins) / 255; // Normalize 0-1

            // Calculate Mids - approx middle 20%
            let midSum = 0;
            const midStart = Math.floor(this.dataArray.length * 0.2);
            const midEnd = Math.floor(this.dataArray.length * 0.4);
            for(let i=midStart; i<midEnd; i++) midSum += this.dataArray[i];
            this.mids = (midSum / (midEnd - midStart)) / 255;
        }
    }

    class VisionManager {
        constructor(onGesture) {
            this.hands = null;
            this.camera = null;
            this.onGesture = onGesture;
            this.lastGesture = 'IDLE';
            this.cooldown = 0;
        }

        init() {
            const videoElement = document.getElementById('video-feed');
            
            this.hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            this.hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Lite model for performance
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            this.hands.onResults(this.onResults.bind(this));

            this.camera = new Camera(videoElement, {
                onFrame: async () => {
                    await this.hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });

            this.camera.start()
                .then(() => {
                    document.getElementById('vision-status').textContent = "ONLINE";
                    document.getElementById('vision-status').style.color = "#0f0";
                })
                .catch(e => {
                    console.error("Camera failed", e);
                    document.getElementById('vision-status').textContent = "ERROR";
                    document.getElementById('vision-status').style.color = "#f00";
                });
        }

        detectGesture(landmarks) {
            // Simple geometry-based gesture recognition
            
            // Tips of fingers
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // Bases (MCP)
            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];
            const wrist = landmarks[0];

            // 1. Check for Fist (All fingers curled down)
            const isFist = indexTip.y > indexBase.y && 
                           middleTip.y > landmarks[9].y &&
                           ringTip.y > landmarks[13].y &&
                           pinkyTip.y > pinkyBase.y;

            if (isFist) return 'FIST';

            // 2. Check for Pinch (Thumb and Index close)
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            if (pinchDist < 0.05) return 'PINCH';

            // 3. Default Open Palm
            return 'PALM';
        }

        onResults(results) {
            if (this.cooldown > 0) {
                this.cooldown--;
                return;
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const gesture = this.detectGesture(landmarks);
                
                if (gesture !== this.lastGesture) {
                    this.lastGesture = gesture;
                    this.onGesture(gesture);
                    this.cooldown = 10; // Debounce frames
                }
            }
        }
    }

    class HologramApp {
        constructor() {
            this.container = document.getElementById('canvas-container');
            this.scene = new THREE.Scene();
            // Cinematic fog
            this.scene.fog = new THREE.FogExp2(0x000000, 0.02);
            
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.z = 18;
            this.camera.position.y = 2;

            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for mobile
            this.container.appendChild(this.renderer.domElement);

            this.clock = new THREE.Clock();
            
            // State
            this.state = {
                explodeLevel: 0,    // 0 to 1
                targetExplode: 0,
                scanRadius: 0,
                isScanning: false
            };

            this.initParticles();
            this.setupEvents();
        }

        initParticles() {
            // Count considerations: 
            // Desktop: 50k+ is fine. 
            // Mobile: 15k is safe.
            const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
            const particleCount = isMobile ? 15000 : 40000;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const basePositions = new Float32Array(particleCount * 3);
            const randoms = new Float32Array(particleCount);

            const radius = 6;

            for (let i = 0; i < particleCount; i++) {
                // Sphere distribution
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                basePositions[i * 3] = x;
                basePositions[i * 3 + 1] = y;
                basePositions[i * 3 + 2] = z;

                randoms[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('basePosition', new THREE.BufferAttribute(basePositions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            this.material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uExplode: { value: 0 },
                    uAudioLow: { value: 0 },
                    uAudioMid: { value: 0 },
                    uScanRadius: { value: 0 },
                    uScanActive: { value: 0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            this.particleSystem = new THREE.Points(geometry, this.material);
            this.scene.add(this.particleSystem);
        }

        handleGesture(gesture) {
            const statusEl = document.getElementById('sys-status');
            
            switch(gesture) {
                case 'FIST':
                    this.state.targetExplode = 1.0;
                    statusEl.textContent = "CORE UNSTABLE";
                    statusEl.style.color = "#ffaa00";
                    break;
                case 'PALM':
                    this.state.targetExplode = 0.0;
                    statusEl.textContent = "CORE STABLE";
                    statusEl.style.color = "#0ff";
                    break;
                case 'PINCH':
                    this.triggerScan();
                    statusEl.textContent = "SCANNING...";
                    statusEl.style.color = "#fff";
                    break;
            }
        }

        triggerScan() {
            if (this.state.isScanning) return;
            this.state.isScanning = true;
            this.state.scanRadius = 0;
            this.material.uniforms.uScanActive.value = 1.0;
        }

        update() {
            const dt = this.clock.getDelta();
            const elapsed = this.clock.getElapsedTime();

            // 1. Update Uniforms
            this.material.uniforms.uTime.value = elapsed;

            // 2. Smooth Explode Transition
            this.state.explodeLevel += (this.state.targetExplode - this.state.explodeLevel) * 2.0 * dt;
            this.material.uniforms.uExplode.value = this.state.explodeLevel;

            // 3. Scan Wave Logic
            if (this.state.isScanning) {
                this.state.scanRadius += 15.0 * dt; // Speed of scan
                this.material.uniforms.uScanRadius.value = this.state.scanRadius;
                
                if (this.state.scanRadius > 30.0) {
                    this.state.isScanning = false;
                    this.material.uniforms.uScanActive.value = 0.0;
                    document.getElementById('sys-status').textContent = "STANDBY";
                    document.getElementById('sys-status').style.color = "#0ff";
                }
            }

            // 4. Subtle rotation
            this.particleSystem.rotation.y += 0.05 * dt;
            
            // 5. Audio Binding
            if (audioManager && audioManager.active) {
                audioManager.update();
                // Smooth filtering for audio values to prevent flicker
                this.material.uniforms.uAudioLow.value = THREE.MathUtils.lerp(
                    this.material.uniforms.uAudioLow.value, 
                    audioManager.lows, 
                    0.1
                );
                this.material.uniforms.uAudioMid.value = THREE.MathUtils.lerp(
                    this.material.uniforms.uAudioMid.value, 
                    audioManager.mids, 
                    0.1
                );
            }
        }

        render() {
            this.renderer.render(this.scene, this.camera);
        }

        setupEvents() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    }

    // --- MAIN EXECUTION ---
    
    let app, audioManager, visionManager;

    document.getElementById('start-btn').addEventListener('click', async (e) => {
        // Hide button
        e.target.style.display = 'none';
        
        // Init Systems
        app = new HologramApp();
        audioManager = new AudioManager();
        
        visionManager = new VisionManager((gesture) => {
            app.handleGesture(gesture);
        });

        // Async inits
        await audioManager.init();
        visionManager.init();

        // Start Loop
        animate();
    });

    function animate() {
        requestAnimationFrame(animate);
        if (app) {
            app.update();
            app.render();
        }
    }

    </script>
</body>
</html>
