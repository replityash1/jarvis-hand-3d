<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jarvis Holographic Core</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            display: none;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 255, 255, 0.6);
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(0, 255, 255, 0.8);
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <video id="video" playsinline></video>
    <div id="status">INITIALIZING...</div>
    <div id="info">
        Gestures: OPEN PALM → Scan Mode | FIST → Idle Mode<br>
        Audio reactive via microphone
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ============================================
        // GLOBAL STATE & CONFIGURATION
        // ============================================
        
        const CONFIG = {
            particleCount: 8000,
            coreRadius: 2.5,
            explodeDistance: 6.0,
            animationSpeed: 1.2,
            scanWaveSpeed: 0.8,
            audioSensitivity: {
                low: 0.3,
                mid: 0.5,
                high: 0.2
            }
        };

        const STATE = {
            mode: 'idle', // 'idle' or 'scan'
            exploding: false,
            scanWaveActive: false,
            audioEnabled: false,
            gestureEnabled: false,
            lastGesture: 'none',
            explodeProgress: 0, // 0 = rest, 1 = fully exploded
            scanWaveProgress: 0 // 0 to 1
        };

        let scene, camera, renderer, particleSystem;
        let audioContext, analyser, dataArray, microphone;
        let hands, cameraStream;
        
        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================
        
        function initScene() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 8;
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Ambient light for scene depth
            const ambientLight = new THREE.AmbientLight(0x00ffff, 0.1);
            scene.add(ambientLight);
        }

        // ============================================
        // PARTICLE SYSTEM WITH CUSTOM SHADERS
        // ============================================
        
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const basePositions = new Float32Array(CONFIG.particleCount * 3); // Store rest positions
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const phases = new Float32Array(CONFIG.particleCount); // For individual animation variation
            
            // Generate particles in a spherical distribution
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // Fibonacci sphere distribution for even coverage
                const phi = Math.acos(1 - 2 * (i + 0.5) / CONFIG.particleCount);
                const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                
                const radius = CONFIG.coreRadius * (0.3 + Math.random() * 0.7);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                // Store base positions for explosions
                basePositions[i3] = x;
                basePositions[i3 + 1] = y;
                basePositions[i3 + 2] = z;
                
                // Cyan to blue gradient
                const colorMix = Math.random();
                colors[i3] = colorMix * 0.3; // R
                colors[i3 + 1] = 0.8 + colorMix * 0.2; // G
                colors[i3 + 2] = 1.0; // B
                
                sizes[i] = 0.03 + Math.random() * 0.05;
                phases[i] = Math.random() * Math.PI * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('basePosition', new THREE.BufferAttribute(basePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
            
            // ============================================
            // VERTEX SHADER
            // ============================================
            const vertexShader = `
                uniform float time;
                uniform float explodeProgress;
                uniform float scanWaveProgress;
                uniform float audioLow;
                uniform float audioMid;
                
                attribute vec3 basePosition;
                attribute vec3 color;
                attribute float size;
                attribute float phase;
                
                varying vec3 vColor;
                varying float vBrightness;
                varying float vDistanceFromCenter;
                
                void main() {
                    // Start from base position
                    vec3 pos = basePosition;
                    
                    // Calculate distance from origin (for scan wave)
                    float distFromCenter = length(pos);
                    vDistanceFromCenter = distFromCenter;
                    
                    // AMBIENT BREATHING (idle animation)
                    float breathe = sin(time * 0.5 + phase) * 0.1;
                    pos += normalize(pos) * breathe * (1.0 - explodeProgress);
                    
                    // AUDIO REACTIVE EXPANSION (low frequencies)
                    float audioExpand = audioLow * 0.5;
                    pos += normalize(pos) * audioExpand;
                    
                    // EXPLODE ANIMATION
                    // Smoothly move particles outward from base position
                    vec3 explodeDir = normalize(basePosition);
                    float explodeDist = 6.0; // How far to explode
                    pos += explodeDir * explodeDist * explodeProgress;
                    
                    // SCAN WAVE DISPLACEMENT
                    // Create a spherical wave that pushes particles outward
                    float waveRadius = scanWaveProgress * 10.0;
                    float waveDist = abs(distFromCenter - waveRadius);
                    float waveEffect = smoothstep(1.0, 0.0, waveDist / 0.5);
                    pos += normalize(pos) * waveEffect * 0.3;
                    
                    // Calculate brightness for scan wave
                    vBrightness = 1.0 + waveEffect * 2.0 + audioMid * 0.5;
                    
                    vColor = color;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Size with distance attenuation
                    float finalSize = size * 100.0 * (1.0 + audioMid * 0.3);
                    gl_PointSize = finalSize * (300.0 / -mvPosition.z);
                }
            `;
            
            // ============================================
            // FRAGMENT SHADER
            // ============================================
            const fragmentShader = `
                uniform float time;
                
                varying vec3 vColor;
                varying float vBrightness;
                varying float vDistanceFromCenter;
                
                void main() {
                    // Create circular particle shape
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    
                    // Smooth circular particle with glow
                    float alpha = smoothstep(0.5, 0.2, dist);
                    
                    // Add glow ring
                    float glow = smoothstep(0.5, 0.0, dist) * 0.3;
                    alpha += glow;
                    
                    // CRITICAL: Clamp alpha to prevent complete invisibility
                    // Even at minimum, particles remain slightly visible
                    alpha = clamp(alpha, 0.1, 1.0);
                    
                    // Apply brightness from scan wave and audio
                    float brightness = clamp(vBrightness, 0.5, 3.0);
                    
                    vec3 finalColor = vColor * brightness;
                    
                    // Holographic shimmer effect
                    float shimmer = sin(time * 2.0 + vDistanceFromCenter * 3.0) * 0.1 + 0.9;
                    finalColor *= shimmer;
                    
                    gl_FragColor = vec4(finalColor, alpha * 0.8);
                }
            `;
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    explodeProgress: { value: 0 },
                    scanWaveProgress: { value: 0 },
                    audioLow: { value: 0 },
                    audioMid: { value: 0 }
                },
                vertexShader,
                fragmentShader,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // ============================================
        // AUDIO SYSTEM (Web Audio API)
        // ============================================
        
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                STATE.audioEnabled = true;
                updateStatus('AUDIO: ONLINE');
            } catch (err) {
                console.warn('Audio not available:', err);
                updateStatus('AUDIO: OFFLINE');
            }
        }

        function getAudioData() {
            if (!STATE.audioEnabled || !analyser) {
                return { low: 0, mid: 0, high: 0 };
            }
            
            analyser.getByteFrequencyData(dataArray);
            
            const low = dataArray.slice(0, 8).reduce((a, b) => a + b) / 8 / 255;
            const mid = dataArray.slice(8, 32).reduce((a, b) => a + b) / 24 / 255;
            const high = dataArray.slice(32, 64).reduce((a, b) => a + b) / 32 / 255;
            
            return {
                low: low * CONFIG.audioSensitivity.low,
                mid: mid * CONFIG.audioSensitivity.mid,
                high: high * CONFIG.audioSensitivity.high
            };
        }

        // ============================================
        // GESTURE RECOGNITION (MediaPipe Hands)
        // ============================================
        
        async function initGestures() {
            try {
                const video = document.getElementById('video');
                
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // Faster for mobile
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandResults);
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' }
                });
                
                video.srcObject = stream;
                video.play();
                
                const camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
                
                STATE.gestureEnabled = true;
                updateStatus('GESTURES: ONLINE');
            } catch (err) {
                console.warn('Gestures not available:', err);
                updateStatus('GESTURES: OFFLINE');
            }
        }

        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                return;
            }
            
            const landmarks = results.multiHandLandmarks[0];
            const gesture = detectGesture(landmarks);
            
            if (gesture !== STATE.lastGesture) {
                handleGesture(gesture);
                STATE.lastGesture = gesture;
            }
        }

        function detectGesture(landmarks) {
            // Simple gesture detection based on finger positions
            const wrist = landmarks[0];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const thumbTip = landmarks[4];
            
            // Calculate average height of fingertips relative to wrist
            const avgFingerHeight = (indexTip.y + middleTip.y + ringTip.y + pinkyTip.y) / 4;
            const fingerSpread = Math.abs(indexTip.x - pinkyTip.x);
            
            // OPEN PALM: fingers extended and spread
            if (avgFingerHeight < wrist.y - 0.1 && fingerSpread > 0.15) {
                return 'open_palm';
            }
            
            // FIST: fingers curled
            if (avgFingerHeight > wrist.y - 0.05 && fingerSpread < 0.1) {
                return 'fist';
            }
            
            return 'none';
        }

        function handleGesture(gesture) {
            if (gesture === 'open_palm') {
                enterScanMode();
            } else if (gesture === 'fist') {
                enterIdleMode();
            }
        }

        // ============================================
        // MODE TRANSITIONS & ANIMATIONS
        // ============================================
        
        function enterScanMode() {
            if (STATE.mode === 'scan') return;
            
            STATE.mode = 'scan';
            STATE.scanWaveActive = true;
            STATE.scanWaveProgress = 0;
            STATE.exploding = true;
            
            updateStatus('MODE: SCANNING');
        }

        function enterIdleMode() {
            if (STATE.mode === 'idle') return;
            
            STATE.mode = 'idle';
            STATE.exploding = false;
            
            updateStatus('MODE: IDLE');
        }

        function updateAnimations(deltaTime) {
            const speed = CONFIG.animationSpeed;
            
            // EXPLODE/REASSEMBLE ANIMATION
            if (STATE.exploding) {
                // Explode outward
                STATE.explodeProgress = Math.min(STATE.explodeProgress + deltaTime * speed, 1.0);
            } else {
                // Reassemble back to rest position
                STATE.explodeProgress = Math.max(STATE.explodeProgress - deltaTime * speed, 0.0);
            }
            
            // SCAN WAVE ANIMATION
            if (STATE.scanWaveActive) {
                STATE.scanWaveProgress += deltaTime * CONFIG.scanWaveSpeed;
                
                // Wave completes after full expansion
                if (STATE.scanWaveProgress >= 1.0) {
                    STATE.scanWaveActive = false;
                    STATE.scanWaveProgress = 0;
                }
            }
            
            // Update shader uniforms
            if (particleSystem) {
                particleSystem.material.uniforms.explodeProgress.value = STATE.explodeProgress;
                particleSystem.material.uniforms.scanWaveProgress.value = STATE.scanWaveProgress;
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Update animations
            updateAnimations(deltaTime);
            
            // Get audio data
            const audio = getAudioData();
            
            // Update shader uniforms
            if (particleSystem) {
                particleSystem.material.uniforms.time.value = currentTime / 1000;
                particleSystem.material.uniforms.audioLow.value = audio.low;
                particleSystem.material.uniforms.audioMid.value = audio.mid;
                
                // Gentle rotation for cinematic feel
                particleSystem.rotation.y += deltaTime * 0.05;
                particleSystem.rotation.x = Math.sin(currentTime / 10000) * 0.1;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // ============================================
        // UI & UTILITIES
        // ============================================
        
        function updateStatus(text) {
            const status = document.getElementById('status');
            const lines = status.innerHTML.split('<br>');
            
            // Keep last 3 status lines
            if (lines.length >= 3) {
                lines.shift();
            }
            
            lines.push(text);
            status.innerHTML = lines.join('<br>');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        
        async function init() {
            initScene();
            createParticleSystem();
            
            // Initialize audio and gestures asynchronously
            await Promise.all([
                initAudio(),
                initGestures()
            ]);
            
            window.addEventListener('resize', onWindowResize);
            
            updateStatus('SYSTEM: ONLINE');
            animate(0);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
