<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Hand Particles</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #fff;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px 0 rgba(0,0,0,0.8); pointer-events: none;
        }
        h2 { margin: 0; font-weight: 300; letter-spacing: 2px; color: #88ccff; }
        .stat { font-family: monospace; color: #00ffcc; font-size: 1.2em; }
        #input_video { display: none; }
    </style>
</head>
<body>
    <video id="input_video"></video>
    <div id="ui">
        <h2>CELESTIAL SYSTEM</h2>
        <div style="margin-top:10px;">Body Type: <span id="shape-name" class="stat">Nebula</span></div>
        <div>Gravitational Pull: <span id="dist-val" class="stat">0</span></div>
    </div>

    <script>
        const scene = new THREE.Scene();
        // Add subtle background stars
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(3000 * 3);
        for(let i=0; i<9000; i++) starPos[i] = (Math.random() - 0.5) * 100;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x444444, size: 0.1}));
        scene.add(stars);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x020205);
        document.body.appendChild(renderer.domElement);

        const state = { handPos: new THREE.Vector3(), expansion: 0.1, templateIdx: 0, isFist: false, lastFistTime: 0 };

        const templates = [
            { name: "Nebula Core", color: new THREE.Color(0xaa00ff) },
            { name: "Solar Flare", color: new THREE.Color(0xff5500) },
            { name: "Saturn Rings", color: new THREE.Color(0x00aaff) },
            { name: "Supernova", color: new THREE.Color(0xffffff) }
        ];

        const count = 80000;
        const geo = new THREE.BufferGeometry();
        const posArray = new Float32Array(count * 3);
        const attrArray = new Float32Array(count * 3); // size, speed, phase

        for(let i=0; i<count; i++) {
            posArray[i*3] = (Math.random() - 0.5) * 10;
            posArray[i*3+1] = (Math.random() - 0.5) * 10;
            posArray[i*3+2] = (Math.random() - 0.5) * 10;
            
            attrArray[i*3] = Math.random() * 2.0 + 0.5; // Size
            attrArray[i*3+1] = Math.random() * 2.0;     // Speed
            attrArray[i*3+2] = Math.random() * 6.28;    // Phase
        }

        geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geo.setAttribute('a_attr', new THREE.BufferAttribute(attrArray, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { value: 0 },
                u_expand: { value: 0 },
                u_type: { value: 0 },
                u_center: { value: new THREE.Vector3() },
                u_color: { value: templates[0].color }
            },
            vertexShader: `
                uniform float u_time;
                uniform float u_expand;
                uniform int u_type;
                uniform vec3 u_center;
                attribute vec3 a_attr;
                varying float vAlpha;
                
                void main() {
                    float size = a_attr.x;
                    float speed = a_attr.y;
                    float phase = a_attr.z;
                    float t = u_time * (0.5 + speed * 0.5) + phase;
                    
                    vec3 p = position;
                    vec3 finalPos;

                    if(u_type == 0) { // Nebula Core
                        float r = 3.0 + sin(t) * 0.5;
                        finalPos = vec3(sin(t + phase)*r, cos(t*0.5 + phase)*r, sin(t*0.2)*r);
                    } else if(u_type == 1) { // Solar Flare
                        float r = 2.0 + u_expand * 5.0 * a_attr.x;
                        finalPos = normalize(position) * r * (0.8 + sin(t*3.0)*0.2);
                    } else if(u_type == 2) { // Saturn Rings
                        float inner = 4.0;
                        float outer = 8.0;
                        float r = inner + (outer - inner) * (phase/6.28);
                        finalPos = vec3(cos(t)*r, sin(t)*0.1, sin(t)*r);
                    } else { // Supernova
                        float burst = mod(u_time * 0.8, 3.0);
                        finalPos = normalize(position) * burst * 10.0 * a_attr.x;
                    }

                    finalPos *= (u_expand * 2.0 + 0.4);
                    finalPos += u_center;

                    vec4 mvPos = modelViewMatrix * vec4(finalPos, 1.0);
                    gl_PointSize = size * (30.0 / -mvPos.z) * (1.0 + u_expand * 2.0);
                    vAlpha = smoothstep(3.0, 0.0, length(finalPos - u_center) * 0.1);
                    gl_Position = projectionMatrix * mvPos;
                }
            `,
            fragmentShader: `
                uniform vec3 u_color;
                varying float vAlpha;
                void main() {
                    float d = length(gl_PointCoord - 0.5);
                    if(d > 0.5) discard;
                    // Planet shading: bright center, soft glow
                    float strength = pow(1.0 - d*2.0, 2.0);
                    gl_FragColor = vec4(u_color, strength * vAlpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false
        });

        const points = new THREE.Points(geo, material);
        scene.add(points);

        // --- MEDIAPIPE LOGIC ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const landmarks = results.multiHandLandmarks[0];
                const m = landmarks[9];
                state.handPos.set((m.x - 0.5) * -40, (m.y - 0.5) * -25, (m.z * -20));

                const thumb = landmarks[4], index = landmarks[8];
                const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                state.expansion = THREE.MathUtils.clamp((dist - 0.05) / 0.35, 0, 1);
                document.getElementById('dist-val').innerText = Math.round(state.expansion * 100) + "%";

                const wrist = landmarks[0];
                const isFist = Math.hypot(landmarks[12].x - wrist.x, landmarks[12].y - wrist.y) < 0.12;
                if(isFist && !state.isFist && (Date.now() - state.lastFistTime > 1000)) {
                    state.templateIdx = (state.templateIdx + 1) % templates.length;
                    state.lastFistTime = Date.now();
                    document.getElementById('shape-name').innerText = templates[state.templateIdx].name;
                }
                state.isFist = isFist;
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.u_time.value += 0.015;
            material.uniforms.u_center.value.lerp(state.handPos, 0.08); // Higher lerp = more "weight"
            material.uniforms.u_expand.value = THREE.MathUtils.lerp(material.uniforms.u_expand.value, state.expansion, 0.1);
            material.uniforms.u_type.value = state.templateIdx;
            material.uniforms.u_color.value.lerp(templates[state.templateIdx].color, 0.05);
            
            // Subtle camera sway
            camera.position.x += (state.handPos.x * 0.05 - camera.position.x) * 0.02;
            camera.lookAt(0,0,0);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
